package Bot::Cobalt::Lang;
our $VERSION = '0.003';

## Emitted events:
##  langset_loaded ($lang, $lang-specified, $path)
##
## Loads from __DATA__ first (added at build-time by Lang.pm.PL)
## This provides an up-to-date default English set in case the 
## on-disk langset is old / incomplete / broken / missing.

use 5.10.1;
use strictures 1;
use Carp;

use Moo::Role;

use Bot::Cobalt::Serializer;

use File::Spec;

sub langset_load { load_langset(@_) }
sub load_langset {  ## load_langset(language)
  ## read specified language out of etc/langs/
  ## return hash suitable for core->lang
  my ($self) = shift;
  my $lang = shift || croak 'no language specified?';
  ## you can specify a prefix
  ## f.ex: load_langset('english', '/some/dir/langs/plugin-')
  ## results in: $path = "/some/dir/langs/plugin-". lc($lang) .".yml"
  my $prefix = shift || File::Spec->catdir( $self->cfg->{path}, "langs" );

  ## etc/langs/language.yml (lowercase expected)
  my $path = File::Spec->catfile( $prefix, lc($lang).".yml" );

  unless (-f $path) {
    $self->send_event( 'langset_error', "not found: ($lang) $path" )
      if $self->can('send_event');
    $self->log->warn("langset not found: $lang ($path)")
      if $self->can('log');
    return { }
  }

  $self->log->info("Loading language set: $lang")
    if $self->can('log');

  my %opts;
  $opts{Logger} = $self->log if $self->can('log');
  my $serializer = Bot::Cobalt::Serializer->new(%opts);
  my $langset = $serializer->readfile($path);

  ## Load __DATA__'s english langset:
  my $default_langset_yaml = <DATA> ;
  my $default_langset = $serializer->thaw($default_langset_yaml);

  my $extern_rev  = $langset->{SPEC} // 0;
  my $builtin_rev = $default_langset->{SPEC} // 0;
  
  ## not a prefixed load, probably a core langset.
  ## is the on-disk set out of date?
  if (!$prefix && $builtin_rev > $extern_rev) {
      $self->log->warn(
        "This appears to be a core langset load, but the internal",
        " set has a higher SPEC number than $path:",
        " $builtin_rev vs. $extern_rev -- you may want to update langsets.",
      ) if $self->can('log');
  }
  
  ## Push anything missing in $langset
  ## (but only if there was no prefix specified)
  ## If there was, this is probably a plugin langset
  unless ($prefix) {
    for my $rpl (keys %{ $default_langset->{RPL} }) {
      unless (exists $langset->{RPL}->{$rpl}) {
        my $default_repl = $default_langset->{RPL}->{$rpl};
        $langset->{RPL}->{$rpl} = $default_repl;
        $self->log->debug("pushed missing RPL from default set: $rpl")
          if $self->can('log');
      }
    }
  }

  ## FIXME langset validation ?

  unless (scalar keys %{ $langset->{RPL} }) {
    $self->send_event( 'langset_error', "empty langset? $lang ($path)" )
      if $self->can('send_event');

    $self->log->warn("empty language set? no keys for $lang ($path)")
      if $self->can('log');
    return { }
  }

  $self->send_event( 'langset_loaded', lc($lang), $path )
    if $self->can('send_event');

  return $langset->{RPL}
}

### this module will have a langset appended at build-time ###

no Moo; 1;
__DATA__
